{"ast":null,"code":"import _slicedToArray from \"/Users/jalcantara/Desktop/SOL-dev/tanda-wallet-sol/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _regeneratorRuntime from \"/Users/jalcantara/Desktop/SOL-dev/tanda-wallet-sol/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _classCallCheck from \"/Users/jalcantara/Desktop/SOL-dev/tanda-wallet-sol/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/jalcantara/Desktop/SOL-dev/tanda-wallet-sol/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/jalcantara/Desktop/SOL-dev/tanda-wallet-sol/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/jalcantara/Desktop/SOL-dev/tanda-wallet-sol/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/jalcantara/Desktop/SOL-dev/tanda-wallet-sol/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _asyncToGenerator from \"/Users/jalcantara/Desktop/SOL-dev/tanda-wallet-sol/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport Transport from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/lib/hid-framing\";\nimport { identifyUSBProductId, ledgerUSBVendorId } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport { TransportOpenUserCancelled, DisconnectedDeviceDuringOperation, DisconnectedDevice, TransportError } from \"@ledgerhq/errors\";\nvar ledgerDevices = [{\n  vendorId: ledgerUSBVendorId\n}];\n\nvar isSupported = function isSupported() {\n  return Promise.resolve(!!(global.navigator && global.navigator.hid));\n};\n\nvar getHID = function getHID() {\n  // $FlowFixMe\n  var _navigator = navigator,\n      hid = _navigator.hid;\n  if (!hid) throw new TransportError(\"navigator.hid is not supported\", \"HIDNotSupported\");\n  return hid;\n};\n\nfunction requestLedgerDevices() {\n  return _requestLedgerDevices.apply(this, arguments);\n}\n\nfunction _requestLedgerDevices() {\n  _requestLedgerDevices = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n    var device;\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _context6.next = 2;\n            return getHID().requestDevice({\n              filters: ledgerDevices\n            });\n\n          case 2:\n            device = _context6.sent;\n\n            if (!Array.isArray(device)) {\n              _context6.next = 5;\n              break;\n            }\n\n            return _context6.abrupt(\"return\", device);\n\n          case 5:\n            return _context6.abrupt(\"return\", [device]);\n\n          case 6:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n  return _requestLedgerDevices.apply(this, arguments);\n}\n\nfunction getLedgerDevices() {\n  return _getLedgerDevices.apply(this, arguments);\n}\n\nfunction _getLedgerDevices() {\n  _getLedgerDevices = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n    var devices;\n    return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            _context7.next = 2;\n            return getHID().getDevices();\n\n          case 2:\n            devices = _context7.sent;\n            return _context7.abrupt(\"return\", devices.filter(function (d) {\n              return d.vendorId === ledgerUSBVendorId;\n            }));\n\n          case 4:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n  return _getLedgerDevices.apply(this, arguments);\n}\n\nfunction getFirstLedgerDevice() {\n  return _getFirstLedgerDevice.apply(this, arguments);\n}\n/**\n * WebHID Transport implementation\n * @example\n * import TransportWebHID from \"@ledgerhq/hw-transport-webhid\";\n * ...\n * TransportWebHID.create().then(transport => ...)\n */\n\n\nfunction _getFirstLedgerDevice() {\n  _getFirstLedgerDevice = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n    var existingDevices, devices;\n    return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            _context8.next = 2;\n            return getLedgerDevices();\n\n          case 2:\n            existingDevices = _context8.sent;\n\n            if (!(existingDevices.length > 0)) {\n              _context8.next = 5;\n              break;\n            }\n\n            return _context8.abrupt(\"return\", existingDevices[0]);\n\n          case 5:\n            _context8.next = 7;\n            return requestLedgerDevices();\n\n          case 7:\n            devices = _context8.sent;\n            return _context8.abrupt(\"return\", devices[0]);\n\n          case 9:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8);\n  }));\n  return _getFirstLedgerDevice.apply(this, arguments);\n}\n\nvar TransportWebHID = /*#__PURE__*/function (_Transport) {\n  _inherits(TransportWebHID, _Transport);\n\n  var _super = _createSuper(TransportWebHID);\n\n  function TransportWebHID(device) {\n    var _this;\n\n    _classCallCheck(this, TransportWebHID);\n\n    _this = _super.call(this);\n    _this.device = void 0;\n    _this.deviceModel = void 0;\n    _this.channel = Math.floor(Math.random() * 0xffff);\n    _this.packetSize = 64;\n    _this.inputs = [];\n    _this.inputCallback = void 0;\n\n    _this.read = function () {\n      if (_this.inputs.length) {\n        return Promise.resolve(_this.inputs.shift());\n      }\n\n      return new Promise(function (success) {\n        _this.inputCallback = success;\n      });\n    };\n\n    _this.onInputReport = function (e) {\n      var buffer = Buffer.from(e.data.buffer);\n\n      if (_this.inputCallback) {\n        _this.inputCallback(buffer);\n\n        _this.inputCallback = null;\n      } else {\n        _this.inputs.push(buffer);\n      }\n    };\n\n    _this._disconnectEmitted = false;\n\n    _this._emitDisconnect = function (e) {\n      if (_this._disconnectEmitted) return;\n      _this._disconnectEmitted = true;\n\n      _this.emit(\"disconnect\", e);\n    };\n\n    _this.exchange = function (apdu) {\n      return _this.exchangeAtomicImpl( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _assertThisInitialize, channel, packetSize, framing, blocks, i, result, acc, buffer;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _assertThisInitialize = _assertThisInitialized(_this), channel = _assertThisInitialize.channel, packetSize = _assertThisInitialize.packetSize;\n                log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n                framing = hidFraming(channel, packetSize); // Write...\n\n                blocks = framing.makeBlocks(apdu);\n                i = 0;\n\n              case 5:\n                if (!(i < blocks.length)) {\n                  _context.next = 11;\n                  break;\n                }\n\n                _context.next = 8;\n                return _this.device.sendReport(0, blocks[i]);\n\n              case 8:\n                i++;\n                _context.next = 5;\n                break;\n\n              case 11:\n                if (result = framing.getReducedResult(acc)) {\n                  _context.next = 18;\n                  break;\n                }\n\n                _context.next = 14;\n                return _this.read();\n\n              case 14:\n                buffer = _context.sent;\n                acc = framing.reduceResponse(acc, buffer);\n                _context.next = 11;\n                break;\n\n              case 18:\n                log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n                return _context.abrupt(\"return\", result);\n\n              case 20:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }))).catch(function (e) {\n        if (e && e.message && e.message.includes(\"write\")) {\n          _this._emitDisconnect(e);\n\n          throw new DisconnectedDeviceDuringOperation(e.message);\n        }\n\n        throw e;\n      });\n    };\n\n    _this.device = device;\n    _this.deviceModel = identifyUSBProductId(device.productId);\n    device.addEventListener(\"inputreport\", _this.onInputReport);\n    return _this;\n  }\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n\n\n  _createClass(TransportWebHID, [{\n    key: \"close\",\n\n    /**\n     * Release the transport device\n     */\n    value: function () {\n      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.exchangeBusyPromise;\n\n              case 2:\n                this.device.removeEventListener(\"inputreport\", this.onInputReport);\n                _context2.next = 5;\n                return this.device.close();\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function close() {\n        return _close.apply(this, arguments);\n      }\n\n      return close;\n    }()\n    /**\n     * Exchange with the device using APDU protocol.\n     * @param apdu\n     * @returns a promise of apdu response\n     */\n\n  }, {\n    key: \"setScrambleKey\",\n    value: function setScrambleKey() {}\n  }], [{\n    key: \"request\",\n    value: function () {\n      var _request = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var _yield$requestLedgerD, _yield$requestLedgerD2, device;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return requestLedgerDevices();\n\n              case 2:\n                _yield$requestLedgerD = _context3.sent;\n                _yield$requestLedgerD2 = _slicedToArray(_yield$requestLedgerD, 1);\n                device = _yield$requestLedgerD2[0];\n                return _context3.abrupt(\"return\", TransportWebHID.open(device));\n\n              case 6:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function request() {\n        return _request.apply(this, arguments);\n      }\n\n      return request;\n    }()\n    /**\n     * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n     */\n\n  }, {\n    key: \"openConnected\",\n    value: function () {\n      var _openConnected = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var devices;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return getLedgerDevices();\n\n              case 2:\n                devices = _context4.sent;\n\n                if (!(devices.length === 0)) {\n                  _context4.next = 5;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", null);\n\n              case 5:\n                return _context4.abrupt(\"return\", TransportWebHID.open(devices[0]));\n\n              case 6:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      function openConnected() {\n        return _openConnected.apply(this, arguments);\n      }\n\n      return openConnected;\n    }()\n    /**\n     * Create a Ledger transport with a HIDDevice\n     */\n\n  }, {\n    key: \"open\",\n    value: function () {\n      var _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(device) {\n        var transport, onDisconnect;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return device.open();\n\n              case 2:\n                transport = new TransportWebHID(device);\n\n                onDisconnect = function onDisconnect(e) {\n                  if (device === e.device) {\n                    getHID().removeEventListener(\"disconnect\", onDisconnect);\n\n                    transport._emitDisconnect(new DisconnectedDevice());\n                  }\n                };\n\n                getHID().addEventListener(\"disconnect\", onDisconnect);\n                return _context5.abrupt(\"return\", transport);\n\n              case 6:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }));\n\n      function open(_x) {\n        return _open.apply(this, arguments);\n      }\n\n      return open;\n    }()\n  }]);\n\n  return TransportWebHID;\n}(Transport);\n\nexport { TransportWebHID as default };\nTransportWebHID.isSupported = isSupported;\nTransportWebHID.list = getLedgerDevices;\n\nTransportWebHID.listen = function (observer) {\n  var unsubscribed = false;\n  getFirstLedgerDevice().then(function (device) {\n    if (!device) {\n      observer.error(new TransportOpenUserCancelled(\"Access denied to use Ledger device\"));\n    } else if (!unsubscribed) {\n      var deviceModel = identifyUSBProductId(device.productId);\n      observer.next({\n        type: \"add\",\n        descriptor: device,\n        deviceModel: deviceModel\n      });\n      observer.complete();\n    }\n  }, function (error) {\n    observer.error(new TransportOpenUserCancelled(error.message));\n  });\n\n  function unsubscribe() {\n    unsubscribed = true;\n  }\n\n  return {\n    unsubscribe: unsubscribe\n  };\n};","map":{"version":3,"sources":["../src/TransportWebHID.js"],"names":["ledgerDevices","vendorId","ledgerUSBVendorId","isSupported","Promise","global","getHID","hid","device","filters","Array","devices","d","existingDevices","getLedgerDevices","requestLedgerDevices","TransportWebHID","deviceModel","channel","Math","packetSize","constructor","identifyUSBProductId","success","e","buffer","Buffer","list","listen","observer","unsubscribed","getFirstLedgerDevice","type","descriptor","error","unsubscribe","transport","onDisconnect","apdu","log","framing","hidFraming","blocks","i","result","acc"],"mappings":"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","sourcesContent":["//@flow\nimport Transport from \"@ledgerhq/hw-transport\";\nimport type {\n  Observer,\n  DescriptorEvent,\n  Subscription,\n} from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/lib/hid-framing\";\nimport { identifyUSBProductId, ledgerUSBVendorId } from \"@ledgerhq/devices\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport {\n  TransportOpenUserCancelled,\n  DisconnectedDeviceDuringOperation,\n  DisconnectedDevice,\n  TransportError,\n} from \"@ledgerhq/errors\";\n\nconst ledgerDevices = [{ vendorId: ledgerUSBVendorId }];\n\nconst isSupported = () =>\n  Promise.resolve(!!(global.navigator && global.navigator.hid));\n\nconst getHID = (): HID => {\n  // $FlowFixMe\n  const { hid } = navigator;\n  if (!hid)\n    throw new TransportError(\n      \"navigator.hid is not supported\",\n      \"HIDNotSupported\"\n    );\n  return hid;\n};\n\nasync function requestLedgerDevices(): Promise<HIDDevice[]> {\n  const device = await getHID().requestDevice({ filters: ledgerDevices });\n  if (Array.isArray(device)) return device;\n  return [device];\n}\n\nasync function getLedgerDevices(): Promise<HIDDevice[]> {\n  const devices = await getHID().getDevices();\n  return devices.filter((d) => d.vendorId === ledgerUSBVendorId);\n}\n\nasync function getFirstLedgerDevice(): Promise<HIDDevice> {\n  const existingDevices = await getLedgerDevices();\n  if (existingDevices.length > 0) return existingDevices[0];\n  const devices = await requestLedgerDevices();\n  return devices[0];\n}\n\n/**\n * WebHID Transport implementation\n * @example\n * import TransportWebHID from \"@ledgerhq/hw-transport-webhid\";\n * ...\n * TransportWebHID.create().then(transport => ...)\n */\nexport default class TransportWebHID extends Transport<HIDDevice> {\n  device: HIDDevice;\n  deviceModel: ?DeviceModel;\n  channel = Math.floor(Math.random() * 0xffff);\n  packetSize = 64;\n\n  constructor(device: HIDDevice) {\n    super();\n    this.device = device;\n    this.deviceModel = identifyUSBProductId(device.productId);\n    device.addEventListener(\"inputreport\", this.onInputReport);\n  }\n\n  inputs = [];\n  inputCallback: ?(Buffer) => void;\n\n  read = (): Promise<Buffer> => {\n    if (this.inputs.length) {\n      return Promise.resolve(this.inputs.shift());\n    }\n    return new Promise((success) => {\n      this.inputCallback = success;\n    });\n  };\n\n  onInputReport = (e: InputReportEvent) => {\n    const buffer = Buffer.from(e.data.buffer);\n    if (this.inputCallback) {\n      this.inputCallback(buffer);\n      this.inputCallback = null;\n    } else {\n      this.inputs.push(buffer);\n    }\n  };\n\n  /**\n   * Check if WebUSB transport is supported.\n   */\n  static isSupported = isSupported;\n\n  /**\n   * List the WebUSB devices that was previously authorized by the user.\n   */\n  static list = getLedgerDevices;\n\n  /**\n   * Actively listen to WebUSB devices and emit ONE device\n   * that was either accepted before, if not it will trigger the native permission UI.\n   *\n   * Important: it must be called in the context of a UI click!\n   */\n  static listen = (\n    observer: Observer<DescriptorEvent<HIDDevice>>\n  ): Subscription => {\n    let unsubscribed = false;\n    getFirstLedgerDevice().then(\n      (device) => {\n        if (!device) {\n          observer.error(\n            new TransportOpenUserCancelled(\"Access denied to use Ledger device\")\n          );\n        } else if (!unsubscribed) {\n          const deviceModel = identifyUSBProductId(device.productId);\n          observer.next({ type: \"add\", descriptor: device, deviceModel });\n          observer.complete();\n        }\n      },\n      (error) => {\n        observer.error(new TransportOpenUserCancelled(error.message));\n      }\n    );\n    function unsubscribe() {\n      unsubscribed = true;\n    }\n    return { unsubscribe };\n  };\n\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n  static async request() {\n    const [device] = await requestLedgerDevices();\n    return TransportWebHID.open(device);\n  }\n\n  /**\n   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n   */\n  static async openConnected() {\n    const devices = await getLedgerDevices();\n    if (devices.length === 0) return null;\n    return TransportWebHID.open(devices[0]);\n  }\n\n  /**\n   * Create a Ledger transport with a HIDDevice\n   */\n  static async open(device: HIDDevice) {\n    await device.open();\n    const transport = new TransportWebHID(device);\n    const onDisconnect = (e) => {\n      if (device === e.device) {\n        getHID().removeEventListener(\"disconnect\", onDisconnect);\n        transport._emitDisconnect(new DisconnectedDevice());\n      }\n    };\n    getHID().addEventListener(\"disconnect\", onDisconnect);\n    return transport;\n  }\n\n  _disconnectEmitted = false;\n  _emitDisconnect = (e: Error) => {\n    if (this._disconnectEmitted) return;\n    this._disconnectEmitted = true;\n    this.emit(\"disconnect\", e);\n  };\n\n  /**\n   * Release the transport device\n   */\n  async close(): Promise<void> {\n    await this.exchangeBusyPromise;\n    this.device.removeEventListener(\"inputreport\", this.onInputReport);\n    await this.device.close();\n  }\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  exchange = (apdu: Buffer): Promise<Buffer> =>\n    this.exchangeAtomicImpl(async () => {\n      const { channel, packetSize } = this;\n      log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n\n      const framing = hidFraming(channel, packetSize);\n\n      // Write...\n      const blocks = framing.makeBlocks(apdu);\n      for (let i = 0; i < blocks.length; i++) {\n        await this.device.sendReport(0, blocks[i]);\n      }\n\n      // Read...\n      let result;\n      let acc;\n      while (!(result = framing.getReducedResult(acc))) {\n        const buffer = await this.read();\n        acc = framing.reduceResponse(acc, buffer);\n      }\n\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    }).catch((e) => {\n      if (e && e.message && e.message.includes(\"write\")) {\n        this._emitDisconnect(e);\n        throw new DisconnectedDeviceDuringOperation(e.message);\n      }\n      throw e;\n    });\n\n  setScrambleKey() {}\n}\n"]},"metadata":{},"sourceType":"module"}