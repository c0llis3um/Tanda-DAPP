{"ast":null,"code":"import _classCallCheck from \"/Users/jalcantara/Desktop/SOL-dev/Tanda-DAPP/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/jalcantara/Desktop/SOL-dev/Tanda-DAPP/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport camelCase from \"camelcase\";\nimport * as borsh from \"@project-serum/borsh\";\nimport { IdlCoder } from \"./idl\";\nimport { sighash } from \"./common\";\n/**\n * Namespace for state method function signatures.\n */\n\nexport var SIGHASH_STATE_NAMESPACE = \"state\";\n/**\n * Namespace for global instruction function signatures (i.e. functions\n * that aren't namespaced by the state or any of its trait implementations).\n */\n\nexport var SIGHASH_GLOBAL_NAMESPACE = \"global\";\n/**\n * Encodes and decodes program instructions.\n */\n\nexport var InstructionCoder = /*#__PURE__*/function () {\n  function InstructionCoder(idl) {\n    _classCallCheck(this, InstructionCoder);\n\n    this.ixLayout = InstructionCoder.parseIxLayout(idl);\n  }\n  /**\n   * Encodes a program instruction.\n   */\n\n\n  _createClass(InstructionCoder, [{\n    key: \"encode\",\n    value: function encode(ixName, ix) {\n      return this._encode(SIGHASH_GLOBAL_NAMESPACE, ixName, ix);\n    }\n    /**\n     * Encodes a program state instruction.\n     */\n\n  }, {\n    key: \"encodeState\",\n    value: function encodeState(ixName, ix) {\n      return this._encode(SIGHASH_STATE_NAMESPACE, ixName, ix);\n    }\n  }, {\n    key: \"_encode\",\n    value: function _encode(nameSpace, ixName, ix) {\n      var buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n\n      var methodName = camelCase(ixName);\n      var len = this.ixLayout.get(methodName).encode(ix, buffer);\n      var data = buffer.slice(0, len);\n      return Buffer.concat([sighash(nameSpace, ixName), data]);\n    }\n  }], [{\n    key: \"parseIxLayout\",\n    value: function parseIxLayout(idl) {\n      var stateMethods = idl.state ? idl.state.methods : [];\n      var ixLayouts = stateMethods.map(function (m) {\n        var fieldLayouts = m.args.map(function (arg) {\n          return IdlCoder.fieldLayout(arg, idl.types);\n        });\n        var name = camelCase(m.name);\n        return [name, borsh.struct(fieldLayouts, name)];\n      }).concat(idl.instructions.map(function (ix) {\n        var fieldLayouts = ix.args.map(function (arg) {\n          return IdlCoder.fieldLayout(arg, idl.types);\n        });\n        var name = camelCase(ix.name);\n        return [name, borsh.struct(fieldLayouts, name)];\n      })); // @ts-ignore\n\n      return new Map(ixLayouts);\n    }\n  }]);\n\n  return InstructionCoder;\n}();","map":{"version":3,"sources":["../../../src/coder/instruction.ts"],"names":[],"mappings":";;AAAA,OAAO,SAAP,MAAsB,WAAtB;AAEA,OAAO,KAAK,KAAZ,MAAuB,sBAAvB;AAEA,SAAS,QAAT,QAAyB,OAAzB;AACA,SAAS,OAAT,QAAwB,UAAxB;AAEA;;AAEG;;AACH,OAAO,IAAM,uBAAuB,GAAG,OAAhC;AACP;;;AAGG;;AACH,OAAO,IAAM,wBAAwB,GAAG,QAAjC;AAEP;;AAEG;;AACH,WAAa,gBAAb;AAME,4BAAmB,GAAnB,EAA2B;AAAA;;AACzB,SAAK,QAAL,GAAgB,gBAAgB,CAAC,aAAjB,CAA+B,GAA/B,CAAhB;AACD;AAED;;AAEG;;;AAZL;AAAA;AAAA,2BAagB,MAbhB,EAagC,EAbhC,EAauC;AACnC,aAAO,KAAK,OAAL,CAAa,wBAAb,EAAuC,MAAvC,EAA+C,EAA/C,CAAP;AACD;AAED;;AAEG;;AAnBL;AAAA;AAAA,gCAoBqB,MApBrB,EAoBqC,EApBrC,EAoB4C;AACxC,aAAO,KAAK,OAAL,CAAa,uBAAb,EAAsC,MAAtC,EAA8C,EAA9C,CAAP;AACD;AAtBH;AAAA;AAAA,4BAwBkB,SAxBlB,EAwBqC,MAxBrC,EAwBqD,EAxBrD,EAwB4D;AACxD,UAAM,MAAM,GAAG,MAAM,CAAC,KAAP,CAAa,IAAb,CAAf,CADwD,CACrB;;AACnC,UAAM,UAAU,GAAG,SAAS,CAAC,MAAD,CAA5B;AACA,UAAM,GAAG,GAAG,KAAK,QAAL,CAAc,GAAd,CAAkB,UAAlB,EAA8B,MAA9B,CAAqC,EAArC,EAAyC,MAAzC,CAAZ;AACA,UAAM,IAAI,GAAG,MAAM,CAAC,KAAP,CAAa,CAAb,EAAgB,GAAhB,CAAb;AACA,aAAO,MAAM,CAAC,MAAP,CAAc,CAAC,OAAO,CAAC,SAAD,EAAY,MAAZ,CAAR,EAA6B,IAA7B,CAAd,CAAP;AACD;AA9BH;AAAA;AAAA,kCAgC+B,GAhC/B,EAgCuC;AACnC,UAAM,YAAY,GAAG,GAAG,CAAC,KAAJ,GAAY,GAAG,CAAC,KAAJ,CAAU,OAAtB,GAAgC,EAArD;AAEA,UAAM,SAAS,GAAG,YAAY,CAC3B,GADe,CACX,UAAC,CAAD,EAAsB;AACzB,YAAI,YAAY,GAAG,CAAC,CAAC,IAAF,CAAO,GAAP,CAAW,UAAC,GAAD,EAAkB;AAC9C,iBAAO,QAAQ,CAAC,WAAT,CAAqB,GAArB,EAA0B,GAAG,CAAC,KAA9B,CAAP;AACD,SAFkB,CAAnB;AAGA,YAAM,IAAI,GAAG,SAAS,CAAC,CAAC,CAAC,IAAH,CAAtB;AACA,eAAO,CAAC,IAAD,EAAO,KAAK,CAAC,MAAN,CAAa,YAAb,EAA2B,IAA3B,CAAP,CAAP;AACD,OAPe,EAQf,MARe,CASd,GAAG,CAAC,YAAJ,CAAiB,GAAjB,CAAqB,UAAC,EAAD,EAAO;AAC1B,YAAI,YAAY,GAAG,EAAE,CAAC,IAAH,CAAQ,GAAR,CAAY,UAAC,GAAD;AAAA,iBAC7B,QAAQ,CAAC,WAAT,CAAqB,GAArB,EAA0B,GAAG,CAAC,KAA9B,CAD6B;AAAA,SAAZ,CAAnB;AAGA,YAAM,IAAI,GAAG,SAAS,CAAC,EAAE,CAAC,IAAJ,CAAtB;AACA,eAAO,CAAC,IAAD,EAAO,KAAK,CAAC,MAAN,CAAa,YAAb,EAA2B,IAA3B,CAAP,CAAP;AACD,OAND,CATc,CAAlB,CAHmC,CAoBnC;;AACA,aAAO,IAAI,GAAJ,CAAQ,SAAR,CAAP;AACD;AAtDH;;AAAA;AAAA","sourceRoot":"","sourcesContent":["import camelCase from \"camelcase\";\nimport * as borsh from \"@project-serum/borsh\";\nimport { IdlCoder } from \"./idl\";\nimport { sighash } from \"./common\";\n/**\n * Namespace for state method function signatures.\n */\nexport const SIGHASH_STATE_NAMESPACE = \"state\";\n/**\n * Namespace for global instruction function signatures (i.e. functions\n * that aren't namespaced by the state or any of its trait implementations).\n */\nexport const SIGHASH_GLOBAL_NAMESPACE = \"global\";\n/**\n * Encodes and decodes program instructions.\n */\nexport class InstructionCoder {\n    constructor(idl) {\n        this.ixLayout = InstructionCoder.parseIxLayout(idl);\n    }\n    /**\n     * Encodes a program instruction.\n     */\n    encode(ixName, ix) {\n        return this._encode(SIGHASH_GLOBAL_NAMESPACE, ixName, ix);\n    }\n    /**\n     * Encodes a program state instruction.\n     */\n    encodeState(ixName, ix) {\n        return this._encode(SIGHASH_STATE_NAMESPACE, ixName, ix);\n    }\n    _encode(nameSpace, ixName, ix) {\n        const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n        const methodName = camelCase(ixName);\n        const len = this.ixLayout.get(methodName).encode(ix, buffer);\n        const data = buffer.slice(0, len);\n        return Buffer.concat([sighash(nameSpace, ixName), data]);\n    }\n    static parseIxLayout(idl) {\n        const stateMethods = idl.state ? idl.state.methods : [];\n        const ixLayouts = stateMethods\n            .map((m) => {\n            let fieldLayouts = m.args.map((arg) => {\n                return IdlCoder.fieldLayout(arg, idl.types);\n            });\n            const name = camelCase(m.name);\n            return [name, borsh.struct(fieldLayouts, name)];\n        })\n            .concat(idl.instructions.map((ix) => {\n            let fieldLayouts = ix.args.map((arg) => IdlCoder.fieldLayout(arg, idl.types));\n            const name = camelCase(ix.name);\n            return [name, borsh.struct(fieldLayouts, name)];\n        }));\n        // @ts-ignore\n        return new Map(ixLayouts);\n    }\n}\n//# sourceMappingURL=instruction.js.map"]},"metadata":{},"sourceType":"module"}