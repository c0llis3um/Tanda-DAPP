{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/jalcantara/Desktop/SOL-dev/tanda-wallet-sol/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/jalcantara/Desktop/SOL-dev/tanda-wallet-sol/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _toConsumableArray = require(\"/Users/jalcantara/Desktop/SOL-dev/tanda-wallet-sol/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _objectSpread = require(\"/Users/jalcantara/Desktop/SOL-dev/tanda-wallet-sol/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _classCallCheck = require(\"/Users/jalcantara/Desktop/SOL-dev/tanda-wallet-sol/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jalcantara/Desktop/SOL-dev/tanda-wallet-sol/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MarketProxyBuilder = exports.MarketProxyInstruction = exports.MarketProxy = void 0;\n\nvar anchor_1 = require(\"@project-serum/anchor\");\n\nvar market_1 = require(\"../market\");\n\nvar instructions_1 = require(\"../instructions\"); // MarketProxy provides an API for constructing transactions to an on-chain\n// DEX proxy, which relays all instructions to the orderbook. Minimally, this\n// requires two modifications for DEX instructions.\n//\n// 1. Transasctions are sent to the proxy program--not the DEX.\n// 2. The DEX program ID must be inserted as the first account in instructions\n//    using the proxy relay, so that the proxy can use the account for CPI.\n//    The program is responsible for removing this account before relaying to\n//    the dex.\n//\n// Additionally, a middleware abstraction is provided so that one can configure\n// both the client and the smart contract with the ability to send and processs\n// arbitrary accounts and instruction data *in addition* to what the Serum DEX\n// expects.\n//\n// Similar to the layers of an onion, each middleware wraps a transaction\n// request with additional accounts and instruction data before sending it to\n// the program. Upon receiving the request, the program--with its own set of\n// middleware-- unwraps and processes each layer. The process ends with all\n// layers being unwrapped and the proxy relaying the transaction to the DEX.\n//\n// As a result, the order of the middleware matters and the client should\n// process middleware in the *reverse* order of the proxy smart contract.\n\n\nvar MarketProxy = /*#__PURE__*/function () {\n  // Ctor.\n  function MarketProxy(market, instruction) {\n    _classCallCheck(this, MarketProxy);\n\n    this._market = market;\n    this._instruction = instruction;\n  } // DEX market being proxied.\n\n\n  _createClass(MarketProxy, [{\n    key: \"market\",\n    get: function get() {\n      return this._market;\n    } // Instruction namespace.\n\n  }, {\n    key: \"instruction\",\n    get: function get() {\n      return this._instruction;\n    } // Serum DEX program ID.\n\n  }, {\n    key: \"dexProgramId\",\n    get: function get() {\n      return this._market.programId;\n    } // Proxy program ID.\n\n  }, {\n    key: \"proxyProgramId\",\n    get: function get() {\n      return this._instruction.proxyProgramId;\n    }\n  }]);\n\n  return MarketProxy;\n}();\n\nexports.MarketProxy = MarketProxy; // Instruction builder for the market proxy.\n\nvar MarketProxyInstruction = /*#__PURE__*/function () {\n  function MarketProxyInstruction(proxyProgramId, dexProgramId, market, middlewares) {\n    _classCallCheck(this, MarketProxyInstruction);\n\n    this._proxyProgramId = proxyProgramId;\n    this._dexProgramId = dexProgramId;\n    this._market = market;\n    this._middlewares = middlewares;\n  } // Program ID of the permissioning proxy program.\n\n\n  _createClass(MarketProxyInstruction, [{\n    key: \"newOrderV3\",\n    value: function newOrderV3(params) {\n      var tradeIx = this._market.makeNewOrderV3Instruction(_objectSpread(_objectSpread({}, params), {}, {\n        programId: this._proxyProgramId\n      }));\n\n      this._middlewares.forEach(function (mw) {\n        return mw.newOrderV3(tradeIx);\n      });\n\n      return this.proxy(tradeIx);\n    }\n  }, {\n    key: \"initOpenOrders\",\n    value: function initOpenOrders(owner, market, openOrders, marketAuthority) {\n      var ix = instructions_1.DexInstructions.initOpenOrders({\n        market: market,\n        openOrders: openOrders,\n        owner: owner,\n        programId: this._proxyProgramId,\n        marketAuthority: marketAuthority\n      });\n\n      this._middlewares.forEach(function (mw) {\n        return mw.initOpenOrders(ix);\n      });\n\n      return this.proxy(ix);\n    }\n  }, {\n    key: \"cancelOrder\",\n    value: function cancelOrder(owner, order) {\n      var ix = instructions_1.DexInstructions.cancelOrderV2({\n        market: this._market.address,\n        owner: owner,\n        openOrders: order.openOrdersAddress,\n        bids: this._market.decoded.bids,\n        asks: this._market.decoded.asks,\n        eventQueue: this._market.decoded.eventQueue,\n        side: order.side,\n        orderId: order.orderId,\n        openOrdersSlot: order.openOrdersSlot,\n        programId: this._proxyProgramId\n      });\n\n      this._middlewares.forEach(function (mw) {\n        return mw.cancelOrderV2(ix);\n      });\n\n      return this.proxy(ix);\n    }\n  }, {\n    key: \"cancelOrderByClientId\",\n    value: function cancelOrderByClientId(owner, openOrders, clientId) {\n      var ix = instructions_1.DexInstructions.cancelOrderByClientIdV2({\n        market: this._market.address,\n        openOrders: openOrders,\n        owner: owner,\n        bids: this._market.decoded.bids,\n        asks: this._market.decoded.asks,\n        eventQueue: this._market.decoded.eventQueue,\n        clientId: clientId,\n        programId: this._proxyProgramId\n      });\n\n      this._middlewares.forEach(function (mw) {\n        return mw.cancelOrderByClientIdV2(ix);\n      });\n\n      return this.proxy(ix);\n    }\n  }, {\n    key: \"settleFunds\",\n    value: function settleFunds(openOrders, owner, baseWallet, quoteWallet, referrerQuoteWallet) {\n      var ix = instructions_1.DexInstructions.settleFunds({\n        market: this._market.address,\n        openOrders: openOrders,\n        owner: owner,\n        baseVault: this._market.decoded.baseVault,\n        quoteVault: this._market.decoded.quoteVault,\n        baseWallet: baseWallet,\n        quoteWallet: quoteWallet,\n        vaultSigner: anchor_1.utils.publicKey.createProgramAddressSync([this._market.address.toBuffer(), this._market.decoded.vaultSignerNonce.toArrayLike(Buffer, 'le', 8)], this._dexProgramId),\n        programId: this._proxyProgramId,\n        referrerQuoteWallet: referrerQuoteWallet\n      });\n\n      this._middlewares.forEach(function (mw) {\n        return mw.settleFunds(ix);\n      });\n\n      return this.proxy(ix);\n    }\n  }, {\n    key: \"closeOpenOrders\",\n    value: function closeOpenOrders(openOrders, owner, solWallet) {\n      var ix = instructions_1.DexInstructions.closeOpenOrders({\n        market: this._market.address,\n        openOrders: openOrders,\n        owner: owner,\n        solWallet: solWallet,\n        programId: this._proxyProgramId\n      });\n\n      this._middlewares.forEach(function (mw) {\n        return mw.closeOpenOrders(ix);\n      });\n\n      return this.proxy(ix);\n    }\n  }, {\n    key: \"prune\",\n    value: function prune(openOrders, openOrdersOwner, limit) {\n      if (!limit) {\n        limit = 65535;\n      }\n\n      var ix = instructions_1.DexInstructions.prune({\n        market: this._market.address,\n        bids: this._market.decoded.bids,\n        asks: this._market.decoded.asks,\n        eventQueue: this._market.decoded.eventQueue,\n        pruneAuthority: this._market.decoded.pruneAuthority,\n        openOrders: openOrders,\n        openOrdersOwner: openOrdersOwner,\n        programId: this._proxyProgramId,\n        limit: limit\n      });\n\n      this._middlewares.forEach(function (mw) {\n        return mw.prune(ix);\n      });\n\n      return this.proxy(ix);\n    } // Adds the serum dex account to the instruction so that proxies can\n    // relay (CPI requires the executable account).\n\n  }, {\n    key: \"proxy\",\n    value: function proxy(ix) {\n      ix.keys = [{\n        pubkey: this._dexProgramId,\n        isWritable: false,\n        isSigner: false\n      }].concat(_toConsumableArray(ix.keys));\n      return ix;\n    }\n  }, {\n    key: \"proxyProgramId\",\n    get: function get() {\n      return this._proxyProgramId;\n    }\n  }]);\n\n  return MarketProxyInstruction;\n}();\n\nexports.MarketProxyInstruction = MarketProxyInstruction;\n\nvar MarketProxyBuilder = /*#__PURE__*/function () {\n  function MarketProxyBuilder() {\n    _classCallCheck(this, MarketProxyBuilder);\n\n    this._middlewares = [];\n  }\n\n  _createClass(MarketProxyBuilder, [{\n    key: \"middleware\",\n    value: function middleware(mw) {\n      this._middlewares.push(mw);\n\n      return this;\n    }\n  }, {\n    key: \"load\",\n    value: function () {\n      var _load = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref) {\n        var connection, market, _ref$options, options, dexProgramId, proxyProgramId, marketClient, instruction;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                connection = _ref.connection, market = _ref.market, _ref$options = _ref.options, options = _ref$options === void 0 ? {} : _ref$options, dexProgramId = _ref.dexProgramId, proxyProgramId = _ref.proxyProgramId;\n                _context.next = 3;\n                return market_1.Market.load(connection, market, options, dexProgramId, market_1.MARKET_STATE_LAYOUT_V3);\n\n              case 3:\n                marketClient = _context.sent;\n                instruction = new MarketProxyInstruction(proxyProgramId, dexProgramId, marketClient, this._middlewares);\n                return _context.abrupt(\"return\", new MarketProxy(marketClient, instruction));\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function load(_x) {\n        return _load.apply(this, arguments);\n      }\n\n      return load;\n    }()\n  }]);\n\n  return MarketProxyBuilder;\n}();\n\nexports.MarketProxyBuilder = MarketProxyBuilder;","map":{"version":3,"sources":["../../src/market-proxy/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MarketProxyBuilder = exports.MarketProxyInstruction = exports.MarketProxy = void 0;\nconst anchor_1 = require(\"@project-serum/anchor\");\nconst market_1 = require(\"../market\");\nconst instructions_1 = require(\"../instructions\");\n// MarketProxy provides an API for constructing transactions to an on-chain\n// DEX proxy, which relays all instructions to the orderbook. Minimally, this\n// requires two modifications for DEX instructions.\n//\n// 1. Transasctions are sent to the proxy program--not the DEX.\n// 2. The DEX program ID must be inserted as the first account in instructions\n//    using the proxy relay, so that the proxy can use the account for CPI.\n//    The program is responsible for removing this account before relaying to\n//    the dex.\n//\n// Additionally, a middleware abstraction is provided so that one can configure\n// both the client and the smart contract with the ability to send and processs\n// arbitrary accounts and instruction data *in addition* to what the Serum DEX\n// expects.\n//\n// Similar to the layers of an onion, each middleware wraps a transaction\n// request with additional accounts and instruction data before sending it to\n// the program. Upon receiving the request, the program--with its own set of\n// middleware-- unwraps and processes each layer. The process ends with all\n// layers being unwrapped and the proxy relaying the transaction to the DEX.\n//\n// As a result, the order of the middleware matters and the client should\n// process middleware in the *reverse* order of the proxy smart contract.\nclass MarketProxy {\n    // Ctor.\n    constructor(market, instruction) {\n        this._market = market;\n        this._instruction = instruction;\n    }\n    // DEX market being proxied.\n    get market() {\n        return this._market;\n    }\n    // Instruction namespace.\n    get instruction() {\n        return this._instruction;\n    }\n    // Serum DEX program ID.\n    get dexProgramId() {\n        return this._market.programId;\n    }\n    // Proxy program ID.\n    get proxyProgramId() {\n        return this._instruction.proxyProgramId;\n    }\n}\nexports.MarketProxy = MarketProxy;\n// Instruction builder for the market proxy.\nclass MarketProxyInstruction {\n    constructor(proxyProgramId, dexProgramId, market, middlewares) {\n        this._proxyProgramId = proxyProgramId;\n        this._dexProgramId = dexProgramId;\n        this._market = market;\n        this._middlewares = middlewares;\n    }\n    // Program ID of the permissioning proxy program.\n    get proxyProgramId() {\n        return this._proxyProgramId;\n    }\n    newOrderV3(params) {\n        const tradeIx = this._market.makeNewOrderV3Instruction({\n            ...params,\n            programId: this._proxyProgramId,\n        });\n        this._middlewares.forEach((mw) => mw.newOrderV3(tradeIx));\n        return this.proxy(tradeIx);\n    }\n    initOpenOrders(owner, market, openOrders, marketAuthority) {\n        const ix = instructions_1.DexInstructions.initOpenOrders({\n            market,\n            openOrders,\n            owner,\n            programId: this._proxyProgramId,\n            marketAuthority,\n        });\n        this._middlewares.forEach((mw) => mw.initOpenOrders(ix));\n        return this.proxy(ix);\n    }\n    cancelOrder(owner, order) {\n        const ix = instructions_1.DexInstructions.cancelOrderV2({\n            market: this._market.address,\n            owner,\n            openOrders: order.openOrdersAddress,\n            bids: this._market.decoded.bids,\n            asks: this._market.decoded.asks,\n            eventQueue: this._market.decoded.eventQueue,\n            side: order.side,\n            orderId: order.orderId,\n            openOrdersSlot: order.openOrdersSlot,\n            programId: this._proxyProgramId,\n        });\n        this._middlewares.forEach((mw) => mw.cancelOrderV2(ix));\n        return this.proxy(ix);\n    }\n    cancelOrderByClientId(owner, openOrders, clientId) {\n        const ix = instructions_1.DexInstructions.cancelOrderByClientIdV2({\n            market: this._market.address,\n            openOrders,\n            owner,\n            bids: this._market.decoded.bids,\n            asks: this._market.decoded.asks,\n            eventQueue: this._market.decoded.eventQueue,\n            clientId,\n            programId: this._proxyProgramId,\n        });\n        this._middlewares.forEach((mw) => mw.cancelOrderByClientIdV2(ix));\n        return this.proxy(ix);\n    }\n    settleFunds(openOrders, owner, baseWallet, quoteWallet, referrerQuoteWallet) {\n        const ix = instructions_1.DexInstructions.settleFunds({\n            market: this._market.address,\n            openOrders,\n            owner,\n            baseVault: this._market.decoded.baseVault,\n            quoteVault: this._market.decoded.quoteVault,\n            baseWallet,\n            quoteWallet,\n            vaultSigner: anchor_1.utils.publicKey.createProgramAddressSync([\n                this._market.address.toBuffer(),\n                this._market.decoded.vaultSignerNonce.toArrayLike(Buffer, 'le', 8),\n            ], this._dexProgramId),\n            programId: this._proxyProgramId,\n            referrerQuoteWallet,\n        });\n        this._middlewares.forEach((mw) => mw.settleFunds(ix));\n        return this.proxy(ix);\n    }\n    closeOpenOrders(openOrders, owner, solWallet) {\n        const ix = instructions_1.DexInstructions.closeOpenOrders({\n            market: this._market.address,\n            openOrders,\n            owner,\n            solWallet,\n            programId: this._proxyProgramId,\n        });\n        this._middlewares.forEach((mw) => mw.closeOpenOrders(ix));\n        return this.proxy(ix);\n    }\n    prune(openOrders, openOrdersOwner, limit) {\n        if (!limit) {\n            limit = 65535;\n        }\n        const ix = instructions_1.DexInstructions.prune({\n            market: this._market.address,\n            bids: this._market.decoded.bids,\n            asks: this._market.decoded.asks,\n            eventQueue: this._market.decoded.eventQueue,\n            pruneAuthority: this._market.decoded.pruneAuthority,\n            openOrders,\n            openOrdersOwner,\n            programId: this._proxyProgramId,\n            limit,\n        });\n        this._middlewares.forEach((mw) => mw.prune(ix));\n        return this.proxy(ix);\n    }\n    // Adds the serum dex account to the instruction so that proxies can\n    // relay (CPI requires the executable account).\n    proxy(ix) {\n        ix.keys = [\n            { pubkey: this._dexProgramId, isWritable: false, isSigner: false },\n            ...ix.keys,\n        ];\n        return ix;\n    }\n}\nexports.MarketProxyInstruction = MarketProxyInstruction;\nclass MarketProxyBuilder {\n    constructor() {\n        this._middlewares = [];\n    }\n    middleware(mw) {\n        this._middlewares.push(mw);\n        return this;\n    }\n    async load({ connection, market, options = {}, dexProgramId, proxyProgramId, }) {\n        const marketClient = await market_1.Market.load(connection, market, options, dexProgramId, market_1.MARKET_STATE_LAYOUT_V3);\n        const instruction = new MarketProxyInstruction(proxyProgramId, dexProgramId, marketClient, this._middlewares);\n        return new MarketProxy(marketClient, instruction);\n    }\n}\nexports.MarketProxyBuilder = MarketProxyBuilder;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}