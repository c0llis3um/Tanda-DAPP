{"ast":null,"code":"import _regeneratorRuntime from\"/Users/jalcantara/Desktop/SOL-dev/tanda-wallet-sol/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Users/jalcantara/Desktop/SOL-dev/tanda-wallet-sol/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import _classCallCheck from\"/Users/jalcantara/Desktop/SOL-dev/tanda-wallet-sol/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/Users/jalcantara/Desktop/SOL-dev/tanda-wallet-sol/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";import{MARKETS}from'@project-serum/serum';import{MAINNET_URL}from'./connection';export var serumMarkets=function(){var m={};MARKETS.forEach(function(market){var coin=market.name.split('/')[0];if(m[coin]){// Only override a market if it's not deprecated\t.\nif(!m.deprecated){m[coin]={publicKey:market.address,name:market.name.split('/').join('')};}}else{m[coin]={publicKey:market.address,name:market.name.split('/').join('')};}});return m;}();// Create a cached API wrapper to avoid rate limits.\nvar PriceStore=/*#__PURE__*/function(){function PriceStore(){_classCallCheck(this,PriceStore);this.cache=void 0;this.cache={};}_createClass(PriceStore,[{key:\"getPrice\",value:function(){var _getPrice=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(connection,marketName){var _this=this;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:return _context.abrupt(\"return\",new Promise(function(resolve,reject){if(connection._rpcEndpoint!==MAINNET_URL){resolve(undefined);return;}if(_this.cache[marketName]===undefined){fetch(\"https://serum-api.bonfida.com/orderbooks/\".concat(marketName)).then(function(resp){resp.json().then(function(resp){if(resp.data.asks===null||resp.data.bids===null){resolve(undefined);}else if(resp.data.asks.length===0&&resp.data.bids.length===0){resolve(undefined);}else if(resp.data.asks.length===0){resolve(resp.data.bids[0].price);}else if(resp.data.bids.length===0){resolve(resp.data.asks[0].price);}else{var mid=(resp.data.asks[0].price+resp.data.bids[0].price)/2.0;_this.cache[marketName]=mid;resolve(_this.cache[marketName]);}});});}else{return resolve(_this.cache[marketName]);}}));case 1:case\"end\":return _context.stop();}}},_callee);}));function getPrice(_x,_x2){return _getPrice.apply(this,arguments);}return getPrice;}()}]);return PriceStore;}();export var priceStore=new PriceStore();","map":{"version":3,"sources":["/Users/jalcantara/Desktop/SOL-dev/tanda-wallet-sol/src/utils/markets.ts"],"names":["MARKETS","MAINNET_URL","serumMarkets","m","forEach","market","coin","name","split","deprecated","publicKey","address","join","PriceStore","cache","connection","marketName","Promise","resolve","reject","_rpcEndpoint","undefined","fetch","then","resp","json","data","asks","bids","length","price","mid","priceStore"],"mappings":"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","sourcesContent":["import { MARKETS } from '@project-serum/serum';\nimport { PublicKey } from '@solana/web3.js';\nimport { MAINNET_URL } from './connection';\n\ninterface Markets {\n  [coin: string]: {\n    publicKey: PublicKey;\n    name: string;\n    deprecated?: boolean;\n  };\n}\n\nexport const serumMarkets = (() => {\n  const m: Markets = {};\n  MARKETS.forEach((market) => {\n    const coin = market.name.split('/')[0];\n    if (m[coin]) {\n      // Only override a market if it's not deprecated\t.\n      if (!m.deprecated) {\n        m[coin] = {\n          publicKey: market.address,\n          name: market.name.split('/').join(''),\n        };\n      }\n    } else {\n      m[coin] = {\n        publicKey: market.address,\n        name: market.name.split('/').join(''),\n      };\n    }\n  });\n  return m;\n})();\n\n// Create a cached API wrapper to avoid rate limits.\nclass PriceStore {\n  cache: {};\n\n  constructor() {\n    this.cache = {};\n  }\n\n  async getPrice(connection, marketName): Promise<number | undefined> {\n    return new Promise((resolve, reject) => {\n      if (connection._rpcEndpoint !== MAINNET_URL) {\n        resolve(undefined);\n        return;\n      }\n      if (this.cache[marketName] === undefined) {\n        fetch(`https://serum-api.bonfida.com/orderbooks/${marketName}`).then(\n          (resp) => {\n            resp.json().then((resp) => {\n              if (resp.data.asks === null || resp.data.bids === null) {\n                resolve(undefined);\n              } else if (\n                resp.data.asks.length === 0 &&\n                resp.data.bids.length === 0\n              ) {\n                resolve(undefined);\n              } else if (resp.data.asks.length === 0) {\n                resolve(resp.data.bids[0].price);\n              } else if (resp.data.bids.length === 0) {\n                resolve(resp.data.asks[0].price);\n              } else {\n                const mid =\n                  (resp.data.asks[0].price + resp.data.bids[0].price) / 2.0;\n                this.cache[marketName] = mid;\n                resolve(this.cache[marketName]);\n              }\n            });\n          },\n        );\n      } else {\n        return resolve(this.cache[marketName]);\n      }\n    });\n  }\n}\n\nexport const priceStore = new PriceStore();\n"]},"metadata":{},"sourceType":"module"}