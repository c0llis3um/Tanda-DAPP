{"ast":null,"code":"import{Fragment as _Fragment}from\"react/jsx-runtime\";import{jsxs as _jsxs}from\"react/jsx-runtime\";import{jsx as _jsx}from\"react/jsx-runtime\";import _regeneratorRuntime from\"/Users/jalcantara/Desktop/SOL-dev/tanda-wallet-sol/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Users/jalcantara/Desktop/SOL-dev/tanda-wallet-sol/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import _slicedToArray from\"/Users/jalcantara/Desktop/SOL-dev/tanda-wallet-sol/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import{useState}from'react';import{useSnackbar}from'notistack';import Button from'@material-ui/core/Button';import Dialog from'@material-ui/core/Dialog';import DialogTitle from'@material-ui/core/DialogTitle';import DialogContent from'@material-ui/core/DialogContent';import DialogContentText from'@material-ui/core/DialogContentText';import DialogActions from'@material-ui/core/DialogActions';import Link from'@material-ui/core/Link';import TextField from'@material-ui/core/TextField';import CircularProgress from'@material-ui/core/CircularProgress';import FingerprintIcon from'@material-ui/icons/Fingerprint';import{TokenInstructions}from'@project-serum/serum';import{useWalletPublicKeys}from'../utils/wallet';import{useConnection,refreshAccountInfo,getMultipleSolanaAccounts}from'../utils/connection';import{parseTokenAccountData}from'../utils/tokens/data';import{refreshWalletPublicKeys,useWallet}from'../utils/wallet';import{createAssociatedTokenAccount,findAssociatedTokenAddress}from'../utils/tokens';import{sleep}from'../utils/utils';import{useTokenInfos,getTokenInfo}from'../utils/tokens/names';export default function MergeAccountsDialog(_ref){var open=_ref.open,onClose=_ref.onClose;var _useWalletPublicKeys=useWalletPublicKeys(),_useWalletPublicKeys2=_slicedToArray(_useWalletPublicKeys,1),publicKeys=_useWalletPublicKeys2[0];var connection=useConnection();var wallet=useWallet();var _useSnackbar=useSnackbar(),enqueueSnackbar=_useSnackbar.enqueueSnackbar;var _useState=useState(false),_useState2=_slicedToArray(_useState,2),isMerging=_useState2[0],setIsMerging=_useState2[1];var _useState3=useState(''),_useState4=_slicedToArray(_useState3,2),mergeCheck=_useState4[0],setMergeCheck=_useState4[1];var tokenInfos=useTokenInfos();// Merging accounts is a destructive operation that, for each mint,\n//\n// * Creates an associated token account, if not already created\n// * Moves all funds into the associated token account\n// * Closes every account, excluding the associated token account.\n//\n// Although it's ok if this operation fails--since the user can just\n// retry again--it's not a good experience; hence the retry logic.\n// The retry count of 30 is arbitrary and probably overly conservative.\nvar mergeAccounts=/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(){var retryCount,tokenAccounts,groupedTokenAccounts,mints,k,mintGroup,mint,assocTokAddr,tokenInfo,symbol,_args=arguments;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:retryCount=_args.length>0&&_args[0]!==undefined?_args[0]:30;_context.prev=1;if(!(retryCount===0)){_context.next=5;break;}enqueueSnackbar(\"Unable to complete migration. Please try again.\",{variant:'error'});return _context.abrupt(\"return\");case 5:_context.next=7;return getMultipleSolanaAccounts(connection,publicKeys);case 7:tokenAccounts=_context.sent.filter(function(acc){return acc!==null&&acc.account.owner.equals(TokenInstructions.TOKEN_PROGRAM_ID);}).map(function(_ref3){var publicKey=_ref3.publicKey,account=_ref3.account;return{publicKey:publicKey,account:parseTokenAccountData(account.data),owner:account.owner};});// Group the token accounts by mint.\ngroupedTokenAccounts={};tokenAccounts.forEach(function(ta){var key=ta.account.mint.toString();if(groupedTokenAccounts[key]){groupedTokenAccounts[key].push(ta);}else{groupedTokenAccounts[key]=[ta];}});// For each mint, merge them into one, associated token account.\nmints=Object.keys(groupedTokenAccounts);k=0;case 12:if(!(k<mints.length)){_context.next=29;break;}mintGroup=groupedTokenAccounts[mints[k]];if(!(mintGroup.length>0)){_context.next=26;break;}mint=mintGroup[0].account.mint;_context.next=18;return findAssociatedTokenAddress(wallet.publicKey,mint);case 18:assocTokAddr=_context.sent;if(mintGroup.length===1&&assocTokAddr.equals(mintGroup[0].publicKey)){_context.next=26;break;}tokenInfo=getTokenInfo(mint,connection._rpcEndpoint,tokenInfos);symbol=tokenInfo.symbol?tokenInfo.symbol:mint.toString();console.log(\"Migrating \".concat(symbol));enqueueSnackbar(\"Migrating \".concat(symbol),{variant:'info'});_context.next=26;return mergeMint(assocTokAddr,mintGroup,mint,tokenInfo.decimals,wallet,connection,enqueueSnackbar);case 26:k+=1;_context.next=12;break;case 29:_context.next=31;return sleep(5000);case 31:_context.next=33;return refresh(wallet,publicKeys);case 33:// Exit dialogue.\nclose();_context.next=45;break;case 36:_context.prev=36;_context.t0=_context[\"catch\"](1);console.error('There was a problem migrating accounts',_context.t0);enqueueSnackbar('Could not confirm transaction. Please wait.',{variant:'info'});// Sleep to give the RPC nodes some time to catch up.\n_context.next=42;return sleep(10000);case 42:enqueueSnackbar('Retrying migration',{variant:'info'});_context.next=45;return mergeAccounts(retryCount-1);case 45:case\"end\":return _context.stop();}}},_callee,null,[[1,36]]);}));return function mergeAccounts(){return _ref2.apply(this,arguments);};}();var close=function close(){setMergeCheck('');onClose();};var disabled=mergeCheck.toLowerCase()!=='migrate';return/*#__PURE__*/_jsx(Dialog,{disableBackdropClick:isMerging,open:open,onClose:onClose,children:isMerging?/*#__PURE__*/_jsxs(DialogContent,{children:[/*#__PURE__*/_jsx(DialogContentText,{style:{marginBottom:0,textAlign:'center'},children:\"Merging Accounts\"}),/*#__PURE__*/_jsx(\"div\",{style:{display:'flex',justifyContent:'center',padding:'24px'},children:/*#__PURE__*/_jsx(CircularProgress,{})})]}):/*#__PURE__*/_jsxs(_Fragment,{children:[/*#__PURE__*/_jsx(DialogTitle,{children:\"Are you sure you want to migrate tokens?\"}),/*#__PURE__*/_jsxs(DialogContent,{children:[/*#__PURE__*/_jsxs(DialogContentText,{children:[/*#__PURE__*/_jsx(\"b\",{children:\"WARNING\"}),\": This action may break apps that depend on your existing token accounts.\"]}),/*#__PURE__*/_jsxs(DialogContentText,{children:[\"Migrating sends all tokens to\",' ',/*#__PURE__*/_jsx(Link,{href:'https://spl.solana.com/associated-token-account',target:\"_blank\",rel:\"noopener\",children:\"associated token accounts\"}),' ',/*#__PURE__*/_jsx(FingerprintIcon,{style:{marginBottom:'-7px'}}),\". If associated token accounts do not exist, then they will be created.\"]}),/*#__PURE__*/_jsx(DialogContentText,{children:\"If migrating fails during a period of high network load, you will not have lost your funds. Just recontinue the migration from where you left off. If you have a lot of accounts, migrating might take a while.\"}),/*#__PURE__*/_jsx(TextField,{label:\"Please type \\\"migrate\\\" to confirm\",fullWidth:true,variant:\"outlined\",margin:\"normal\",value:mergeCheck,onChange:function onChange(e){return setMergeCheck(e.target.value.trim());}})]}),/*#__PURE__*/_jsxs(DialogActions,{children:[/*#__PURE__*/_jsx(Button,{onClick:close,color:\"primary\",children:\"Cancel\"}),/*#__PURE__*/_jsx(Button,{disabled:disabled,onClick:function onClick(){setIsMerging(true);mergeAccounts().then(function(){enqueueSnackbar('Account migrate complete',{variant:'success'});setIsMerging(false);}).catch(function(err){enqueueSnackbar(\"There was a problem merging your accounts: \".concat(err.toString()),{variant:'error'});setIsMerging(false);});},color:\"secondary\",autoFocus:true,children:\"Migrate\"})]})]})});}// Merges the given array of token accounts into one associated token account.\nfunction mergeMint(_x,_x2,_x3,_x4,_x5,_x6,_x7){return _mergeMint.apply(this,arguments);}function _mergeMint(){_mergeMint=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(assocTokAddr,mintAccountSet,mint,decimals,wallet,connection,enqueueSnackbar){var associatedTokenAccount,k,tokenAccount;return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:if(!(mintAccountSet.length===0)){_context3.next=2;break;}return _context3.abrupt(\"return\");case 2:_context3.next=4;return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(){var assocTok,accInfo,_yield$createAssociat,_yield$createAssociat2,address;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:assocTok=mintAccountSet.map(function(assocTok){return assocTok.publicKey;}).filter(function(tokAddr){return tokAddr.equals(assocTokAddr);}).pop();// Do we already have the token account?\nif(!assocTok){_context2.next=3;break;}return _context2.abrupt(\"return\",assocTok);case 3:_context2.next=5;return connection.getAccountInfo(assocTokAddr);case 5:accInfo=_context2.sent;if(!(accInfo!==null)){_context2.next=8;break;}return _context2.abrupt(\"return\",assocTokAddr);case 8:_context2.next=10;return createAssociatedTokenAccount({connection:connection,wallet:wallet,splTokenMintAddress:mintAccountSet[0].account.mint});case 10:_yield$createAssociat=_context2.sent;_yield$createAssociat2=_slicedToArray(_yield$createAssociat,1);address=_yield$createAssociat2[0];return _context2.abrupt(\"return\",address);case 14:case\"end\":return _context2.stop();}}},_callee2);}))();case 4:associatedTokenAccount=_context3.sent;k=0;case 6:if(!(k<mintAccountSet.length)){_context3.next=15;break;}tokenAccount=mintAccountSet[k];if(!(tokenAccount.publicKey.equals(associatedTokenAccount)===false)){_context3.next=12;break;}if(!(tokenAccount.account.amount>0)){_context3.next=12;break;}_context3.next=12;return wallet.transferToken(tokenAccount.publicKey,associatedTokenAccount,tokenAccount.account.amount,mint,decimals);case 12:k+=1;_context3.next=6;break;case 15:case\"end\":return _context3.stop();}}},_callee3);}));return _mergeMint.apply(this,arguments);}function refresh(_x8,_x9){return _refresh.apply(this,arguments);}function _refresh(){_refresh=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee4(wallet,publicKeys){return _regeneratorRuntime.wrap(function _callee4$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:_context4.next=2;return refreshWalletPublicKeys(wallet);case 2:publicKeys.map(function(publicKey){return refreshAccountInfo(wallet.connection,publicKey,true);});case 3:case\"end\":return _context4.stop();}}},_callee4);}));return _refresh.apply(this,arguments);}","map":{"version":3,"sources":["/Users/jalcantara/Desktop/SOL-dev/tanda-wallet-sol/src/components/MergeAccountsDialog.js"],"names":["useState","useSnackbar","Button","Dialog","DialogTitle","DialogContent","DialogContentText","DialogActions","Link","TextField","CircularProgress","FingerprintIcon","TokenInstructions","useWalletPublicKeys","useConnection","refreshAccountInfo","getMultipleSolanaAccounts","parseTokenAccountData","refreshWalletPublicKeys","useWallet","createAssociatedTokenAccount","findAssociatedTokenAddress","sleep","useTokenInfos","getTokenInfo","MergeAccountsDialog","open","onClose","publicKeys","connection","wallet","enqueueSnackbar","isMerging","setIsMerging","mergeCheck","setMergeCheck","tokenInfos","mergeAccounts","retryCount","variant","tokenAccounts","filter","acc","account","owner","equals","TOKEN_PROGRAM_ID","map","publicKey","data","groupedTokenAccounts","forEach","ta","key","mint","toString","push","mints","Object","keys","k","length","mintGroup","assocTokAddr","tokenInfo","_rpcEndpoint","symbol","console","log","mergeMint","decimals","refresh","close","error","disabled","toLowerCase","marginBottom","textAlign","display","justifyContent","padding","e","target","value","trim","then","catch","err","mintAccountSet","assocTok","tokAddr","pop","getAccountInfo","accInfo","splTokenMintAddress","address","associatedTokenAccount","tokenAccount","amount","transferToken"],"mappings":"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","sourcesContent":["import { useState } from 'react';\nimport { useSnackbar } from 'notistack';\nimport Button from '@material-ui/core/Button';\nimport Dialog from '@material-ui/core/Dialog';\nimport DialogTitle from '@material-ui/core/DialogTitle';\nimport DialogContent from '@material-ui/core/DialogContent';\nimport DialogContentText from '@material-ui/core/DialogContentText';\nimport DialogActions from '@material-ui/core/DialogActions';\nimport Link from '@material-ui/core/Link';\nimport TextField from '@material-ui/core/TextField';\nimport CircularProgress from '@material-ui/core/CircularProgress';\nimport FingerprintIcon from '@material-ui/icons/Fingerprint';\nimport { TokenInstructions } from '@project-serum/serum';\nimport { useWalletPublicKeys } from '../utils/wallet';\nimport {\n  useConnection,\n  refreshAccountInfo,\n  getMultipleSolanaAccounts,\n} from '../utils/connection';\nimport { parseTokenAccountData } from '../utils/tokens/data';\nimport { refreshWalletPublicKeys, useWallet } from '../utils/wallet';\nimport {\n  createAssociatedTokenAccount,\n  findAssociatedTokenAddress,\n} from '../utils/tokens';\nimport { sleep } from '../utils/utils';\nimport { useTokenInfos, getTokenInfo } from '../utils/tokens/names';\n\nexport default function MergeAccountsDialog({ open, onClose }) {\n  const [publicKeys] = useWalletPublicKeys();\n  const connection = useConnection();\n  const wallet = useWallet();\n  const { enqueueSnackbar } = useSnackbar();\n  const [isMerging, setIsMerging] = useState(false);\n  const [mergeCheck, setMergeCheck] = useState('');\n  const tokenInfos = useTokenInfos();\n\n  // Merging accounts is a destructive operation that, for each mint,\n  //\n  // * Creates an associated token account, if not already created\n  // * Moves all funds into the associated token account\n  // * Closes every account, excluding the associated token account.\n  //\n  // Although it's ok if this operation fails--since the user can just\n  // retry again--it's not a good experience; hence the retry logic.\n  // The retry count of 30 is arbitrary and probably overly conservative.\n  const mergeAccounts = async (retryCount = 30) => {\n    try {\n      if (retryCount === 0) {\n        enqueueSnackbar(`Unable to complete migration. Please try again.`, {\n          variant: 'error',\n        });\n        return;\n      }\n      // Fetch all token accounts owned by the wallet. An account is null\n      // if we previously sent the close transaction, but did not receive\n      // a response due to RPC node instability.\n      const tokenAccounts = (\n        await getMultipleSolanaAccounts(connection, publicKeys)\n      )\n        .filter(\n          (acc) =>\n            acc !== null &&\n            acc.account.owner.equals(TokenInstructions.TOKEN_PROGRAM_ID),\n        )\n        .map(({ publicKey, account }) => {\n          return {\n            publicKey,\n            account: parseTokenAccountData(account.data),\n            owner: account.owner,\n          };\n        });\n\n      // Group the token accounts by mint.\n      const groupedTokenAccounts = {};\n      tokenAccounts.forEach((ta) => {\n        const key = ta.account.mint.toString();\n        if (groupedTokenAccounts[key]) {\n          groupedTokenAccounts[key].push(ta);\n        } else {\n          groupedTokenAccounts[key] = [ta];\n        }\n      });\n\n      // For each mint, merge them into one, associated token account.\n      const mints = Object.keys(groupedTokenAccounts);\n      for (let k = 0; k < mints.length; k += 1) {\n        const mintGroup = groupedTokenAccounts[mints[k]];\n        if (mintGroup.length > 0) {\n          const mint = mintGroup[0].account.mint;\n          const assocTokAddr = await findAssociatedTokenAddress(\n            wallet.publicKey,\n            mint,\n          );\n          // Don't merge if the only account is the associated token address.\n          if (\n            !(\n              mintGroup.length === 1 &&\n              assocTokAddr.equals(mintGroup[0].publicKey)\n            )\n          ) {\n            const tokenInfo = getTokenInfo(\n              mint,\n              connection._rpcEndpoint,\n              tokenInfos,\n            );\n            const symbol = tokenInfo.symbol\n              ? tokenInfo.symbol\n              : mint.toString();\n            console.log(`Migrating ${symbol}`);\n            enqueueSnackbar(`Migrating ${symbol}`, {\n              variant: 'info',\n            });\n            await mergeMint(\n              assocTokAddr,\n              mintGroup,\n              mint,\n              tokenInfo.decimals,\n              wallet,\n              connection,\n              enqueueSnackbar,\n            );\n          }\n        }\n      }\n\n      // Wait to give the RPC nodes some time to catch up.\n      await sleep(5000);\n\n      // Refresh the UI to remove any duplicates.\n      await refresh(wallet, publicKeys);\n\n      // Exit dialogue.\n      close();\n    } catch (err) {\n      console.error('There was a problem migrating accounts', err);\n      enqueueSnackbar('Could not confirm transaction. Please wait.', {\n        variant: 'info',\n      });\n\n      // Sleep to give the RPC nodes some time to catch up.\n      await sleep(10000);\n\n      enqueueSnackbar('Retrying migration', { variant: 'info' });\n      await mergeAccounts(retryCount - 1);\n    }\n  };\n  const close = () => {\n    setMergeCheck('');\n    onClose();\n  };\n  const disabled = mergeCheck.toLowerCase() !== 'migrate';\n\n  return (\n    <Dialog disableBackdropClick={isMerging} open={open} onClose={onClose}>\n      {isMerging ? (\n        <DialogContent>\n          <DialogContentText style={{ marginBottom: 0, textAlign: 'center' }}>\n            Merging Accounts\n          </DialogContentText>\n          <div\n            style={{\n              display: 'flex',\n              justifyContent: 'center',\n              padding: '24px',\n            }}\n          >\n            <CircularProgress />\n          </div>\n        </DialogContent>\n      ) : (\n        <>\n          <DialogTitle>Are you sure you want to migrate tokens?</DialogTitle>\n          <DialogContent>\n            <DialogContentText>\n              <b>WARNING</b>: This action may break apps that depend on your\n              existing token accounts.\n            </DialogContentText>\n            <DialogContentText>\n              Migrating sends all tokens to{' '}\n              <Link\n                href={'https://spl.solana.com/associated-token-account'}\n                target=\"_blank\"\n                rel=\"noopener\"\n              >\n                associated token accounts\n              </Link>{' '}\n              <FingerprintIcon style={{ marginBottom: '-7px' }} />. If\n              associated token accounts do not exist, then they will be created.\n            </DialogContentText>\n            <DialogContentText>\n              If migrating fails during a period of high network load, you will\n              not have lost your funds. Just recontinue the migration from where you\n              left off. If you have a lot of accounts, migrating might take a\n              while.\n            </DialogContentText>\n            <TextField\n              label={`Please type \"migrate\" to confirm`}\n              fullWidth\n              variant=\"outlined\"\n              margin=\"normal\"\n              value={mergeCheck}\n              onChange={(e) => setMergeCheck(e.target.value.trim())}\n            />\n          </DialogContent>\n          <DialogActions>\n            <Button onClick={close} color=\"primary\">\n              Cancel\n            </Button>\n            <Button\n              disabled={disabled}\n              onClick={() => {\n                setIsMerging(true);\n                mergeAccounts()\n                  .then(() => {\n                    enqueueSnackbar('Account migrate complete', {\n                      variant: 'success',\n                    });\n                    setIsMerging(false);\n                  })\n                  .catch((err) => {\n                    enqueueSnackbar(\n                      `There was a problem merging your accounts: ${err.toString()}`,\n                      { variant: 'error' },\n                    );\n                    setIsMerging(false);\n                  });\n              }}\n              color=\"secondary\"\n              autoFocus\n            >\n              Migrate\n            </Button>\n          </DialogActions>\n        </>\n      )}\n    </Dialog>\n  );\n}\n\n// Merges the given array of token accounts into one associated token account.\nasync function mergeMint(\n  assocTokAddr,\n  mintAccountSet,\n  mint,\n  decimals,\n  wallet,\n  connection,\n  enqueueSnackbar,\n) {\n  if (mintAccountSet.length === 0) {\n    return;\n  }\n  // Get the associated token account.\n  let associatedTokenAccount = await (async () => {\n    let assocTok = mintAccountSet\n      .map((assocTok) => assocTok.publicKey)\n      .filter((tokAddr) => tokAddr.equals(assocTokAddr))\n      .pop();\n\n    // Do we already have the token account?\n    if (assocTok) {\n      return assocTok;\n    }\n\n    // Check if the associated token account has been created.\n    // This is required due to a sometimes unstable network, where\n    // the account is created, but the client doesn't receive a\n    // response confirmation.\n    const accInfo = await connection.getAccountInfo(assocTokAddr);\n    if (accInfo !== null) {\n      return assocTokAddr;\n    }\n\n    // If it doesn't exist, then make it.\n    const [address] = await createAssociatedTokenAccount({\n      connection,\n      wallet,\n      splTokenMintAddress: mintAccountSet[0].account.mint,\n    });\n\n    return address;\n  })();\n\n  // Send all funds to the associated token account for each account.\n  // Once the funds are transferred, close the duplicated account.\n  for (let k = 0; k < mintAccountSet.length; k += 1) {\n    const tokenAccount = mintAccountSet[k];\n    if (tokenAccount.publicKey.equals(associatedTokenAccount) === false) {\n      if (tokenAccount.account.amount > 0) {\n        await wallet.transferToken(\n          tokenAccount.publicKey,\n          associatedTokenAccount,\n          tokenAccount.account.amount,\n          mint,\n          decimals,\n        );\n      }\n    }\n  }\n}\n\nasync function refresh(wallet, publicKeys) {\n  await refreshWalletPublicKeys(wallet);\n  publicKeys.map((publicKey) =>\n    refreshAccountInfo(wallet.connection, publicKey, true),\n  );\n}\n"]},"metadata":{},"sourceType":"module"}